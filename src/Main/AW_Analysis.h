/////////////////////////////////////////////////////////////////////////////////
// * FB2K Component: Audio Wizard                                            * //
// * Description:    Audio Wizard Analysis Header File                       * //
// * Author:         TT                                                      * //
// * Website:        https://github.com/The-Wizardium/Audio-Wizard           * //
// * Version:        0.1.0                                                   * //
// * Dev. started:   12-12-2024                                              * //
// * Last change:    01-09-2025                                              * //
/////////////////////////////////////////////////////////////////////////////////


#pragma once
#include "AW_Helpers.h"


///////////////////////////////
// * ANALYSIS INTERPOLATOR * //
///////////////////////////////
#pragma region Analysis Interpolator
class AudioWizardAnalysisInterpolator {
public:
	// * TYPE ALIASES * //
	using ChunkData = AWHAudioData::ChunkData;
	using WindowType = AWHAudioDSP::WindowType;

	AudioWizardAnalysisInterpolator(WindowType window, unsigned int taps, unsigned int factor, unsigned int channels);

	size_t ProcessInterpolation(size_t frames, const audioType* in, audioType* out);
	static double CalculateTruePeakLinear(const ChunkData& chkData, AudioWizardAnalysisInterpolator* interp);

private:
	struct Filter {
		std::vector<double> coeff;
		std::vector<unsigned int> index;
	};

	struct InterpolationParams {
		unsigned int channels;
		unsigned int delay;
		unsigned int factor;
		unsigned int taps;
		unsigned int zi;
		std::vector<Filter> filters;
		std::vector<std::vector<double>> z;
	}; InterpolationParams interpolation;

	void SetInterpolatorWindow(WindowType window);
};
#pragma endregion


/////////////////////////
// * ANALYSIS FILTER * //
/////////////////////////
#pragma region Analysis Filter
class AudioWizardAnalysisFilter {
public:
	// * TYPE ALIASES * //
	using ChunkData = AWHAudioData::ChunkData;

	// Filter coefficient storage
	struct FilterCoeffs {
		double b0 = 0.0;
		double b1 = 0.0;
		double b2 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
	};

	// Filter state storage
	struct FilterState {
		double x1 = 0.0;
		double x2 = 0.0;
		double y1 = 0.0;
		double y2 = 0.0;
	};

	struct FilterData {
		std::unique_ptr<AudioWizardAnalysisInterpolator> interp;
		double sampleRate = 0.0;
		std::vector<double> channelWeights;
		std::vector<std::vector<FilterCoeffs>> lowPassFilterCoeffs;
		std::vector<std::vector<FilterState>> lowPassFilterStates;
		std::vector<FilterCoeffs> preFilterCoeffs;
		std::vector<FilterState> preFilterStates;
		std::vector<FilterCoeffs> rlbFilterCoeffs;
		std::vector<FilterState> rlbFilterStates;
	};

	// Precomputed K-Weighted Pre-Filter coefficients generated by GNU Octave 10.2.0
	static inline const std::unordered_map<double, FilterCoeffs> kWeightedPreFilterCoeffs = {
		{ 44100.0,  { 1.5308412300503478, -2.6509799951547297, 1.1690790799215871, -1.6636551132560204, 0.7125954280732254 } },
		{ 48000.0,  { 1.5351248595869702, -2.6916961894063807, 1.1983928108528501, -1.6906592931824103, 0.7324807742158501 } }, // More precise than the ITU
		// { 48000.0,  { 1.53512485958697,   -2.69169618940638,   1.19839281085285,   -1.69065929318241,   0.73248077421585   } }, // Official coeffs from ITU-R BS.1770-5 Table 1
		{ 88200.0,  { 1.5575153755796538, -2.9056270799263451, 1.3613339774722124, -1.8309199879623321, 0.8441422610878527 } },
		{ 96000.0,  { 1.5597142289757966, -2.9267415782510824, 1.3782612023158187, -1.8446094698901085, 0.8558433229306412 } },
		{ 176400.0, { 1.5711153177418462, -3.0365445024046527, 1.4688716119897622, -1.9153293168330516, 0.9187717441600075 } },
		{ 192000.0, { 1.5722272150912791, -3.0472830515615508, 1.4779713409796094, -1.9222022306074886, 0.9251177351168259 } },
		{ 352800.0, { 1.5779729549706938, -3.1028628349677856, 1.5257685143917370, -1.9576471680091398, 0.9585258024037853 } },
		{ 384000.0, { 1.5785316857098703, -3.1082755776498110, 1.5304868086536694, -1.9610874811908132, 0.9618303979045423 } },
		{ 768000.0, { 1.5816948085467064, -3.1389459367312420, 1.5574386554462238, -1.9805419954483210, 0.9807295227100090 } }
	};

	// Precomputed K-Weighted RLB Filter coefficients generated by GNU Octave 10.2.0
	static inline const std::unordered_map<double, FilterCoeffs> kWeightedRLBFilterCoeffs = {
		{ 44100.0,  { 1.0, -2.0, 1.0, -1.9891696736297958, 0.9891990357870396 } },
		{ 48000.0,  { 1.0, -2.0, 1.0, -1.9900474548339797, 0.9900722503662099 } }, // More precise than the ITU
		// { 48000.0,  { 1.0, -2.0, 1.0, -1.99004745483398,   0.99007225036621   } }, // Official coeffs from ITU-R BS.1770-5 Table 2
		{ 88200.0,  { 1.0, -2.0, 1.0, -1.9950175447247156, 0.9950237590409233 } },
		{ 96000.0,  { 1.0, -2.0, 1.0, -1.9950175447247156, 0.9950237590409233 } },
		{ 176400.0, { 1.0, -2.0, 1.0, -1.9972869224238139, 0.9972887650260682 } },
		{ 192000.0, { 1.0, -2.0, 1.0, -1.9975072228407000, 0.9975087783555097 } },
		{ 352800.0, { 1.0, -2.0, 1.0, -1.9986430017647039, 0.9986434627277654 } },
		{ 384000.0, { 1.0, -2.0, 1.0, -1.9987532235575531, 0.9987536126786399 } },
		{ 768000.0, { 1.0, -2.0, 1.0, -1.9993765147526970, 0.9993766120632931 } }
	};

	static double ApplyFilter(const FilterCoeffs& coeffs, FilterState& state, double sample);
	static void DesignKWeightedPreFilter(FilterCoeffs& coeffs, double sampleRate);
	static void DesignKWeightedRLBFilter(FilterCoeffs& coeffs, double sampleRate);
	static void ProcessKWeightedChunk(const ChunkData& chkData, FilterData& ftData, std::vector<double>& buffer);
	static double GetChannelWeight(size_t index, size_t channels);
	static void InitInterpolation(const ChunkData& chkData, FilterData& ftData);
};
#pragma endregion


/////////////////////////////
// * ANALYSIS FULL-TRACK * //
/////////////////////////////
#pragma region Analysis Full-Track
class AudioWizardAnalysisFullTrack {
public:
	// * TYPE ALIASES * //
	using ChunkData = AWHAudioData::ChunkData;
	using BufferSettings = AWHAudioBuffer::BufferSettings;
	using RingBuffer = AWHAudioBuffer::RingBuffer<audioType>;
	using RingBufferSimple = AWHAudioBuffer::RingBufferSimple;

	struct FullTrackData {
		// Filter Data
		AudioWizardAnalysisFilter::FilterData filterData;

		// Configuration and Metadata
		metadb_handle_ptr handle;
		double sampleRate = 0.0;
		size_t channels = 0;
		size_t bitDepth = 0;
		size_t blockSize = 0;
		size_t stepSize = 0;
		size_t shortTermWindow = 0;

		// Original Audio Processing
		RingBuffer originalBlockBuffer{ BufferSettings::BUFFER_CAPACITY_AUDIO_LOW };
		size_t originalSampleCount = 0;
		double originalSquaresSum = 0.0;
		std::vector<double> originalRMSLinearLeft;
		std::vector<double> originalRMSLinearRight;
		std::vector<double> originalPeakLinearLeft;
		std::vector<double> originalPeakLinearRight;

		// Dynamics Processing
		RingBuffer dynamicsBlockBuffer{ BufferSettings::BUFFER_CAPACITY_AUDIO_LOW };
		size_t fftSize = 0;
		std::array<double, AWHAudioFFT::BARK_BAND_NUMBER> barkWeights;
		std::vector<double> hannWindow;
		std::vector<std::vector<double>> bandPowers;
		std::vector<double> bandPowersPrevious;
		std::vector<double> binauralFactor;
		std::vector<double> criticalBandFactor;
		std::vector<double> harmonicComplexityFactor;
		std::vector<double> maskingFactor;
		std::vector<double> frequencyPowers;
		std::vector<double> spectralCentroid;
		std::vector<double> spectralFlatness;
		std::vector<double> spectralFlux;

		// K-Weighted LUFS Processing
		RingBufferSimple integratedBlockSums{ BufferSettings::BUFFER_CAPACITY_SUMS_LOW };
		RingBufferSimple shortTermBlockSums{ BufferSettings::BUFFER_CAPACITY_SUMS_LOW };
		RingBufferSimple pureDynamicsBlockSums{ BufferSettings::BUFFER_CAPACITY_SUMS_LOW };
		double currentBlockSum = 0.0;
		size_t currentBlockFrames = 0;

		// Loudness Histories
		mutable RingBufferSimple loudnessHistory100ms{ BufferSettings::BUFFER_CAPACITY_HISTORY_LOW };
		mutable RingBufferSimple loudnessHistory1s{ BufferSettings::BUFFER_CAPACITY_HISTORY_LOW };
		mutable RingBufferSimple loudnessHistory10s{ BufferSettings::BUFFER_CAPACITY_HISTORY_LOW };
		std::vector<int> histogramOfBlockLoudness;
		std::vector<int> histogramOfBlockLoudnessLRA;

		// Metrics
		double momentaryLUFS = -INFINITY;
		double shortTermLUFS = -INFINITY;
		double integratedLUFS = -INFINITY;
		size_t kWeightedFrames = 0;
		double kWeightedSumSquares = 0.0;
		audioType samplePeakMaxLinear = 0.0;
		audioType truePeakMaxLinear = 0.0;
	};

	struct FullTrackDataDynamics {
		// Configuration and Metadata
		size_t blockCount = 0;
		double blockDurationMs = 0.0;
		double genreFactor = 0.5;

		// Loudness Processing
		double integratedLUFS = 0.0;
		std::vector<double> blockLoudness;
		std::vector<double> validLoudness;
		std::vector<double> correctedLoudness;
		std::vector<double> adaptedLoudness;

		// Spectral Features
		std::vector<double> frequencyPowers;
		std::vector<double> spectralCentroid;
		std::vector<double> spectralFlatness;
		std::vector<double> spectralFlux;
		double spectralCentroidMean = 0.0;
		double spectralFlatnessMean = 0.0;
		double spectralFluxMean = 0.0;

		// Psychoacoustic Factors
		std::vector<double> binauralFactor;
		std::vector<double> criticalBandFactor;
		std::vector<double> harmonicComplexityFactor;
		std::vector<double> maskingFactor;

		// Dynamics Metrics
		std::vector<double> phrasingScore;
		std::vector<double> transientBoosts;
		double transientScore = 0.0;
		double transientDensity = 0.0;
		double variance = 0.0;
		double varianceScale = 0.0;
		double pureDynamics = 0.0;
	};

	struct FullTrackResults {
		metadb_handle_ptr handle;

		// Metadata
		std::wstring artist = L"";
		std::wstring album = L"";
		std::wstring title = L"";
		std::wstring duration = L"";
		std::wstring year = L"";
		std::wstring genre = L"";
		std::wstring format = L"";
		std::wstring channels = L"";
		std::wstring bitDepth = L"";
		std::wstring bitrate = L"";
		std::wstring sampleRate = L"";

		// Metrics
		double momentaryLUFS = -INFINITY;
		double shortTermLUFS = -INFINITY;
		double integratedLUFS = -INFINITY;
		double RMS = -INFINITY;
		double samplePeak = -INFINITY;
		double truePeak = -INFINITY;
		double PSR = -INFINITY;
		double PLR = -INFINITY;
		double crestFactor = -INFINITY;
		double loudnessRange = -INFINITY;
		double dynamicRange = -INFINITY;
		double dynamicRangeAlbum = -INFINITY;
		double pureDynamics = -INFINITY;
		double pureDynamicsAlbum = -INFINITY;
	};

	// * METRICS * //
	static double GetMomentaryLUFSFull(const FullTrackData& ftData);
	static double GetShortTermLUFSFull(const FullTrackData& ftData);
	static double GetIntegratedLUFSFull(const FullTrackData& ftData);
	static double GetRMSFull(const FullTrackData& ftData);
	static double GetSamplePeakFull(const FullTrackData& ftData);
	static double GetTruePeakFull(const FullTrackData& ftData);
	static double GetPSRFull(const FullTrackData& ftData);
	static double GetPLRFull(const FullTrackData& ftData);
	static double GetCrestFactorFull(const FullTrackData& ftData);
	static double GetLoudnessRangeFull(const FullTrackData& ftData);
	static double GetDynamicRangeFull(const FullTrackData& ftData);
	static double GetPureDynamicsFull(const FullTrackData& ftData);
	static std::map<std::wstring, double> GetAlbumMetricFull(
		const std::vector<FullTrackResults>& results, const std::function<double(const FullTrackResults&)>& metricAccessor
	);

	// * DYNAMICS PROCESSING * //
	static void ProcessDynamicsInitialization(const FullTrackData& ftData, FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsLoudnessCorrection(const FullTrackData& ftData, FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsPreliminaryTransient(FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsLoudnessAdaptation(FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsBinauralAdjustment(FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsCognitiveLoudness(const FullTrackData& ftData, FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsTransientBoostsDetection(FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsTransientBoostsAdjustment(FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsSpread(FullTrackDataDynamics& dynamics);
	static void ProcessDynamicsFactors(FullTrackData& ftData);
	static void ProcessDynamicsChunkData(const ChunkData& chkData, FullTrackData& ftData);

	// * GENERAL PROCESSING * //
	static void ProcessKWeightedSum(FullTrackData& ftData, const std::vector<double>& chunkBuffer);
	static void ProcessShortTermLUFS(FullTrackData& ftData);
	static void ProcessIntegratedLUFS(FullTrackData& ftData);
	static void ProcessOriginalBlocks(FullTrackData& ftData);
	static void ProcessOriginalSamples(const ChunkData& chkData, FullTrackData& ftData);
	static void ProcessSamplePeakMax(const ChunkData& chkData, FullTrackData& ftData);
	static void ProcessTruePeakMax(const ChunkData& chkData, FullTrackData& ftData);

	// * MAIN PROCESSING * //
	static void InitFullTrackState(const ChunkData& chkData, FullTrackData& ftData);
	static void TestSyntheticInput(const FullTrackData& ftData);
	static void ResetFullTrackData(FullTrackData& ftData);
	static void ProcessFullTrackChunk(const ChunkData& chkData, FullTrackData& ftData);
	static void ProcessFullTrackResults(metadb_handle_ptr track, const FullTrackData& ftData, FullTrackResults& ftResult);
};
#pragma endregion


////////////////////////////
// * ANALYSIS REAL-TIME * //
////////////////////////////
#pragma region Analysis Real-Time
class AudioWizardAnalysisRealTime {
public:
	// * TYPE ALIASES * //
	using ChunkData = AWHAudioData::ChunkData;
	using BufferSettings = AWHAudioBuffer::BufferSettings;
	using RingBufferSimple = AWHAudioBuffer::RingBufferSimple;

	struct RealTimeData {
		// Configuration and Metadata
		size_t blockSize = 0;
		double blockDurationMs = 0.0;
		size_t blocksTotal = 0;

		// Filter Data
		AudioWizardAnalysisFilter::FilterData filterData;

		// Buffers
		RingBufferSimple kWeightedBuffer{ 1 };
		RingBufferSimple shortTermLUFSBuffer{ 1 };
		RingBufferSimple integratedLUFSBuffer{ 1 };
		RingBufferSimple drRMSBuffer{ 1 };
		RingBufferSimple drPeakBuffer{ 1 };
		RingBufferSimple drRMSBufferLeft{ 1 };
		RingBufferSimple drRMSBufferRight{ 1 };
		RingBufferSimple drPeakBufferLeft{ 1 };
		RingBufferSimple drPeakBufferRight{ 1 };
		RingBufferSimple loudnessHistory100ms{ 1 };
		RingBufferSimple loudnessHistory1s{ 1 };
		RingBufferSimple loudnessHistory10s{ 1 };
		RingBufferSimple bandPowersHistory{ 1 };

		// Loudness processing
		double currentBlockSum = 0.0;
		size_t currentBlockFrames = 0;
		size_t gatedBlockCount = 0;
		double gatedPowerSum = 0.0;
		double gatingLoudnessEMA = 0.0;
		double drPrevious = 0.0;
		double pureDynamicsEMA = 0.0;

		// Dynamics
		size_t fftSize = 0;
		std::array<double, AWHAudioFFT::BARK_BAND_NUMBER> barkWeights;
		std::vector<double> hannWindow;
		std::vector<std::vector<double>> bandPowers;
		std::vector<double> bandPowersPrevious;
		std::vector<double> frequencyPowers;
		std::vector<double> spectralCentroid;
		std::vector<double> spectralFlatness;
		std::vector<double> spectralFlux;
		std::vector<double> harmonicComplexityFactor;
		std::vector<double> maskingFactor;
		double spectralCentroidSum;
		double spectralFlatnessSum;
		double spectralFluxSum;
		double genreFactor;

		// Metrics
		double momentaryLUFS = -INFINITY;
		double shortTermLUFS = -INFINITY;
		double integratedLUFS = -INFINITY;
		double RMS = -INFINITY;
		double leftRMS = -INFINITY;
		double rightRMS = -INFINITY;
		double leftSamplePeak = -INFINITY;
		double rightSamplePeak = -INFINITY;
		double truePeak = -INFINITY;
		double PSR = -INFINITY;
		double PLR = -INFINITY;
		double crestFactor = -INFINITY;
		double dynamicRange = -INFINITY;
		double pureDynamics = -INFINITY;
		double phaseCorrelation = -INFINITY;
		double stereoWidth = -INFINITY;
	};

	struct RealTimeDataDynamics {
		// References
		const ChunkData& chkData;
		RealTimeData& rtData;

		// Configuration and Metadata
		size_t blockCount = 0;
		double blockDurationMs = 0.0;
		size_t frameCounter = 0;
		size_t lastBlockCount = 0;
		double lastSampleRate = 0.0;

		// Loudness Processing
		double integratedLUFS = -INFINITY;
		double prevLufs = -INFINITY;
		double stableDuration = 0.0;
		std::vector<double> blockLoudness;
		std::vector<double> correctedLoudness;
		std::vector<double> adaptedLoudness;
		std::vector<double> transientBoosts;

		// Spectral Features
		std::vector<std::vector<double>> bandPowers;
		std::vector<double> frequencyPowers;
		std::vector<double> spectralCentroid;
		std::vector<double> spectralFlatness;
		std::vector<double> spectralFlux;

		// Psychoacoustic Factors
		std::vector<double> harmonicComplexityFactor;
		std::vector<double> maskingFactor;

		// Binaural Processing
		std::vector<double> stereoBuffer;
		std::vector<double> leftChannel;
		std::vector<double> rightChannel;

		// Dynamics Metrics
		double variance = 0.0;
		double varianceScale = 0.0;
	};

	// * METRICS * //
	static double GetMomentaryLUFS(const ChunkData& chkData, const RealTimeData& rtData);
	static double GetShortTermLUFS(const ChunkData& chkData, const RealTimeData& rtData);
	static double GetRMS(const ChunkData& chkData);
	static double GetTruePeak(const ChunkData& chkData, RealTimeData& rtData);
	static double GetPSR(const ChunkData& chkData, RealTimeData& rtData);
	static double GetPLR(double truePeak, double integratedLUFS);
	static double GetCrestFactor(const ChunkData& chkData);
	static double GetDynamicRange(const ChunkData& chkData, RealTimeData& rtData);
	static double GetPureDynamics(const ChunkData& chkData, RealTimeData& rtData);
	static double GetPhaseCorrelation(const ChunkData& chkData);
	static double GetStereoWidth(const ChunkData& chkData);

	// * DYNAMICS PROCESSING * //
	static void ProcessDynamicsInitialization(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsLoudnessCorrection(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsLoudnessAdaptation(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsBinauralAdjustment(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsCognitiveLoudness(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsTransientBoostsDetection(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsTransientBoostsAdjustment(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsSpread(RealTimeDataDynamics& dynamics);
	static void ProcessDynamicsFactors(const ChunkData& chkData, RealTimeData& rtData);

	// * GENERAL PROCESSING * //
	static double ProcessLUFS(const RingBufferSimple& buffer, size_t maxSamples);
	static void ProcessIntegratedLUFS(const std::vector<double>& tempBuffer, RealTimeData& rtData);
	static std::pair<double, double> ProcessFrameRMS(const ChunkData& chkData);
	static double ProcessFramePeak(const ChunkData& chkData);
	static std::pair<double, double> ProcessFramePeaks(const ChunkData& chkData);

	// * MAIN PROCESSING * //
	static void InitRealTimeState(const ChunkData& chkData, RealTimeData& rtData);
	static void ProcessRealtimeChunk(const ChunkData& chkData, RealTimeData& rtData);
};
#pragma endregion
